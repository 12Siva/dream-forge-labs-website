<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Weaving Your Story... | Dream Forge Labs</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;700;800;900&display=swap" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turn.js/3/turn.min.js" defer></script>

  <style>
    body {
      font-family: 'Exo 2', sans-serif;
      background-color: #f0f0f0;
      display: flex; justify-content: center; align-items: center;
      min-height: 100dvh; overflow: hidden;
    }
    #book-container { width: 90vw; height: 90vh; max-width: 1000px; max-height: 700px; position: relative;}
    #nav-overlay { z-index: 20; }             /* keep overlay above the book */
    #nav-overlay:hover .edge-hint { opacity: .35; }  /* visual fade only */
    #book { width: 100%; height: 100%; box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
    #book .page {
      background: #fff; padding: 2em; font-size: 16px; line-height: 1.6;
      color: #333; overflow: auto; border: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      min-height: 0;   
    }
    #book .page-wrapper { perspective: 2000px; }
    #book .hard {
      background-color: #f2f2f2; font-weight: bold; display: flex;
      justify-content: center; align-items: center; font-size: 2em; color: #333;
    }
    #book .odd { border-left: 0; }
    #book .even { border-right: 0; }
    #book .page.hidden { display: none !important; }
    #book .page-content { height: 100%; display: flex; flex-direction: column;   flex: 1 1 auto;
                          min-height: 0;           /* critical for flex scroll */}

    #book .page-text {
      overflow-wrap: anywhere;
      word-break: break-word;
      flex: 1 1 auto;
      overflow: auto; /* show scrollbar when needed */
      -webkit-overflow-scrolling: touch; /* smooth iOS scrolling */
      padding-right: 0.25rem; /* avoid scrollbar overlay on text */
      color: #333; /* visible in light mode */
    }
    
    .dark #book .page-text {
      color: #d1d5db; /* force visible text in dark mode */
    }
    
    #book .page-text p {
      margin: 0 0 0.75rem;
    }

    
    #book .page-footer { text-align: center; font-size: 0.8em; color: #999; padding-top: 1em; flex-shrink: 0; }
    #status-display { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

    /* Dark mode */
    .dark body { background: #111827; }
    .dark #book .page { background: #1F2937; color: #d1d5db; border-color: #374151; }
    .dark #book .hard { background-color: #111827; color: #f9fafb; }
    .dark #book .page-footer { color: #6b7280; }


    
    /* Big click areas */
    .hotspot {
      position: absolute; top: 0; bottom: 0; width: 22%;
      pointer-events: auto; background: transparent; border: 0; padding: 0; margin: 0;
      cursor: pointer;
    }
    .hotspot.left  { left: 0; }
    .hotspot.right { right: 0; }
    .hotspot:hover ~ .edge-hint.left,
    .hotspot.left:hover ~ .edge-hint.left { opacity: .35; }
    .hotspot:hover ~ .edge-hint.right,
    .hotspot.right:hover ~ .edge-hint.right { opacity: .35; }

    /* Edge hints */
    .edge-hint {
      position: absolute; top: 0; bottom: 0; width: 64px; opacity: .0; pointer-events: none;
      transition: opacity .2s ease;
      background: linear-gradient(to right, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .edge-hint.left  { left: 0; }
    .edge-hint.right { right: 0; transform: scaleX(-1); }
    
    /* Visible buttons + indicator */
    .controls {
      position: absolute; left: 50%; bottom: 16px; transform: translateX(-50%);
      display: flex; align-items: center; gap: .75rem; pointer-events: auto;
    }
    .page-nav-btn {
      width: 40px; height: 40px; border-radius: 9999px; border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.35); color: #fff; font-size: 22px; line-height: 1;
      display: grid; place-items: center;
    }
    .page-nav-btn:hover { background: rgba(0,0,0,.5); }
    .indicator {
      font-size: .9rem; color: rgba(255,255,255,.8); padding: .25rem .5rem;
      background: rgba(0,0,0,.25); border-radius: .5rem; border: 1px solid rgba(255,255,255,.15);
    }
    
    /* Light theme adjustments */
    :root:not(.dark) .page-nav-btn { background: rgba(0,0,0,.15); color: #111; border-color: rgba(0,0,0,.15); }
    :root:not(.dark) .page-nav-btn:hover { background: rgba(0,0,0,.22); }
    :root:not(.dark) .indicator { background: rgba(0,0,0,.08); color: #222; border-color: rgba(0,0,0,.08); }
    
    /* Make the cursor show arrows over hotspots (desktop nicety) */
    @media (pointer:fine) {
      .hotspot.left  { cursor: w-resize; }
      .hotspot.right { cursor: e-resize; }
    }

    /* ---- FINAL OVERRIDES (place at the end) ---- */

    /* Visible paragraph color in both themes */
    #book .page-text { color: #111 !important; }         /* light theme */
    .dark #book .page-text { color: #e5e7eb !important; }/* dark theme */
    
    /* Paragraph spacing */
    #book .page-text p { margin: 0 0 0.75rem; }
    
    /* Ensure overlay doesn't block interaction/selection */
    #nav-overlay { pointer-events: none; z-index: 20; }
    #nav-overlay .hotspot,
    #nav-overlay .controls { pointer-events: auto; }
  </style>

  <script>
    // Prevent FOUC on theme
    if (localStorage.getItem('theme') === 'dark' ||
        (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
</head>
<body class="dark:bg-gray-900">
  <main class="container mx-auto px-6 py-16 flex justify-center items-center">
    <div id="status-display" class="max-w-4xl mx-auto text-center" role="status" aria-live="polite">
      <h1 class="text-4xl md:text-5xl font-extrabold mb-8 text-gray-900 dark:text-gray-50">
        Weaving your new adventure...
      </h1>
      <div id="status-box" class="bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-300 p-4 rounded-lg flex items-center justify-center">
        <svg id="spinner" class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" aria-hidden="true">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span id="status-text">Our storytellers are hard at work. This can take a minute or two. Please wait...</span>
      </div>
    </div>

    <div id="book-container" class="hidden">
      <!-- Navigation overlay -->
      <div id="nav-overlay" class="absolute inset-0">
      
        <!-- large click/tap hotspots -->
        <button id="hot-left"  class="hotspot left"  aria-label="Previous page"></button>
        <button id="hot-right" class="hotspot right" aria-label="Next page"></button>
        <!-- subtle edge hints -->
        <div class="edge-hint left"></div>
        <div class="edge-hint right"></div>
      
        <!-- visible prev/next buttons -->
        <div class="controls">
          <button id="btn-prev" class="page-nav-btn" type="button" aria-label="Previous page">‹</button>
          <div id="pageIndicator" class="indicator" aria-live="polite"></div>
          <button id="btn-next" class="page-nav-btn" type="button" aria-label="Next page">›</button>
        </div>
      </div>
      <div id="book" tabindex="-1"></div>
    </div>
  </main>

  <script>
    const API_BASE_URL = 'https://507041jst3.execute-api.us-east-2.amazonaws.com';
    const statusDisplay = document.getElementById('status-display');
    const statusBox = document.getElementById('status-box');
    const spinner = document.getElementById('spinner');
    const statusText = document.getElementById('status-text');
    const bookContainer = document.getElementById('book-container');
    const book = document.getElementById('book');

    function escapeHTML(s) {
      return s
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    async function getStory(key, signal) {
      try {
        const response = await fetch(`${API_BASE_URL}/get-story?key=${encodeURIComponent(key)}`, { signal });
        if (response.ok) {
          const data = await response.json();
          return data.story;
        }
        if (response.status === 404) return null; // still generating
        return null; // treat other errors as retryable
      } catch (error) {
        if (error.name !== 'AbortError') console.error("Error fetching story:", error);
        return null;
      }
    }
    
    function initTurn() {
      // Guard: is the plugin present?
      if (!$.fn || !$.fn.turn) {
        console.warn('Turn.js plugin not found — using fallback pager.');
        return false;
      }
    
      // Make sure the book is visible and has non-zero size
      const w = bookContainer.clientWidth || 800;
      const h = bookContainer.clientHeight || 600;
    
      try {
        // If it was initialized before (hot reloads etc), destroy and re-init
        if ($(book).data('turn')) $(book).turn('destroy');
    
        $(book).turn({
          width: w,
          height: h,
          elevation: 50,
          gradients: true,
          autoCenter: true,
          // help Turn.js compute spread cleanly
          display: 'double'
        });
    
        // Bind after init (always)
        $(book).off('turned', updateIndicator).on('turned', updateIndicator);
        updateIndicator();
        return true;
      } catch (e) {
        console.error('Turn.js init failed — using fallback pager.', e);
        return false;
      }
    }

    function updateIndicator() {
      const el = document.getElementById('pageIndicator');
      if (!el) return;
      try {
        const page = $(book).turn('page');
        const total = $(book).turn('pages');
        el.textContent = `Page ${page} of ${total}`;
      } catch {
        // ignore — fallback will handle
      }
    }

    function updateIndicatorFallback(page, total) {
      const el = document.getElementById('pageIndicator');
      if (el) el.textContent = `Page ${page} of ${total}`;
    }

    function setupNav(useTurn) {
      const prev = () => {
        if (useTurn && $(book).data('turn')) {
          $(book).turn('previous');
          return;
        }
        // fallback: show previous .page manually
        const pages = [...book.querySelectorAll('.page')];
        const i = pages.findIndex(p => !p.classList.contains('hidden'));
        const prevIdx = Math.max(0, i - 1);
        pages.forEach((p, idx) => p.classList.toggle('hidden', idx !== prevIdx));
        updateIndicatorFallback(prevIdx + 1, pages.length);
      };
    
      const next = () => {
        if (useTurn && $(book).data('turn')) {
          $(book).turn('next');
          return;
        }
        // fallback: show next .page manually
        const pages = [...book.querySelectorAll('.page')];
        const i = pages.findIndex(p => !p.classList.contains('hidden'));
        const nextIdx = Math.min(pages.length - 1, i + 1);
        pages.forEach((p, idx) => p.classList.toggle('hidden', idx !== nextIdx));
        updateIndicatorFallback(nextIdx + 1, pages.length);
      };
    
      document.getElementById('btn-prev')?.addEventListener('click', prev);
      document.getElementById('btn-next')?.addEventListener('click', next);
      document.getElementById('hot-left')?.addEventListener('click', prev);
      document.getElementById('hot-right')?.addEventListener('click', next);
    
      window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') prev();
        if (e.key === 'ArrowRight') next();
      });
    }

    function displayStoryInBook(storyText) {
      document.title = 'Your New Story | Dream Forge Labs';
      statusDisplay.classList.add('hidden');
      statusDisplay.setAttribute('aria-hidden', 'true');
      bookContainer.classList.remove('hidden');
    
      // Normalize any kind of escaped/newline combo
      const normalized = String(storyText ?? '')
        .replace(/\\r/g, '\r')   // literal "\r" → CR
        .replace(/\\n/g, '\n')   // literal "\n" → LF
        .replace(/\r\n/g, '\n')  // CRLF → LF
        .replace(/\r/g, '\n')    // lone CR → LF
        .replace(/\n{3,}/g, '\n\n'); // collapse huge gaps
    
      // Split to paragraphs
      const paras = normalized.split(/\n+/).filter(p => p.trim() !== '');
    
      // Paginate by word count
      const wordsPerPage = 200;
      const pages = [];
      let bucket = [], count = 0;
    
      for (const p of paras) {
        const c = p.trim() ? p.trim().split(/\s+/).length : 0;
        if (bucket.length && count + c > wordsPerPage) {
          pages.push(bucket.join('\n\n'));
          bucket = [p]; count = c;
        } else {
          bucket.push(p); count += c;
        }
      }
      if (bucket.length) pages.push(bucket.join('\n\n'));
      if (!pages.length && normalized.trim()) pages.push(normalized.trim());
    
      // Build DOM
      let html = '';
      html += '<div class="hard"><h1>Your New Story</h1></div>';
      html += '<div class="hard"></div>';
    
      for (let i = 0; i < pages.length; i++) {
        const paraHtml = pages[i]
          .split('\n')
          .map(line => `<p>${escapeHTML(line)}</p>`)
          .join('');
        html += `
          <div class="page">
            <div class="page-content">
              <div class="page-text">${paraHtml}</div>
              <div class="page-footer">Page ${i + 1}</div>
            </div>
          </div>`;
      }
    
      // Make total count even (2 front hards + content + 2 back hards)
      const totalWithBacks = 2 + pages.length + 2;
      if (totalWithBacks % 2 !== 0) {
        html += `<div class="page"><div class="page-content">
                   <div class="page-text"></div><div class="page-footer"></div>
                 </div></div>`;
      }
    
      // Back covers
      html += '<div class="hard"></div><div class="hard"></div>';
    
      // Paint
      book.innerHTML = html;
    
      // Debug: confirm what we rendered
      console.debug('renderedPages', { count: pages.length, first200: pages[0]?.slice(0, 200) });
    
      // (Re)initialize turn + controls
      setTimeout(() => {
        initTurn();
        setupNav();
        updateIndicator?.();
        book.focus?.();
      }, 0);
    }



    document.addEventListener('DOMContentLoaded', () => {
      // Initial loading title already set in <title>
      const params = new URLSearchParams(window.location.search);
      const originalFileName = params.get('fileName');

      if (!originalFileName) {
        statusText.textContent = 'Error: Could not find the story to load.';
        document.title = 'Error Loading Story | Dream Forge Labs';
        return;
      }

      const rewrittenStoryKey = originalFileName.replace(/\.[^/.]+$/, "") + ".rewritten.txt";

      // Exponential backoff polling with abort-on-unload
      let attempts = 0;
      const maxAttempts = 12; // ~5 minutes with backoff
      let delay = 5000; // start at 5s
      let stopped = false;

      const aborters = new Set();
      window.addEventListener('beforeunload', () => {
        stopped = true;
        aborters.forEach(a => a.abort());
      });

      (async function poll() {
        while (!stopped && attempts < maxAttempts) {
          attempts++;
          const ac = new AbortController();
          aborters.add(ac);
          const story = await getStory(rewrittenStoryKey, ac.signal);
          aborters.delete(ac);

          if (story) {
            displayStoryInBook(story);
            return;
          }

          await new Promise(res => setTimeout(res, delay));
          delay = Math.min(Math.floor(delay * 1.5), 30000);
        }

        // Timeout UI
        document.title = 'Story Timed Out | Dream Forge Labs';
        if (spinner) spinner.style.display = 'none';
        statusText.textContent = 'Sorry, the story is taking longer than expected to create.';

        const button = document.createElement('a');
        button.href = `app.html?fileName=${encodeURIComponent(originalFileName)}`;
        button.className = 'bg-[#F97316] hover:bg-[#EA580C] text-white font-bold py-2 px-4 rounded-lg text-md transition-all duration-300 ml-4';
        button.textContent = 'Try Again';

        statusBox.classList.remove('bg-blue-100','dark:bg-blue-900/30','text-blue-800','dark:text-blue-300');
        statusBox.classList.add('bg-red-100','dark:bg-red-900/30','text-red-800','dark:text-red-300');
        statusBox.appendChild(button);

        console.error("Max polling attempts reached. Stopping.");
      })();
    });
  </script>
</body>
</html>
